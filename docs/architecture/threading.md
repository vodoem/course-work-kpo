# Многопоточность и синхронизация (без таймеров)

## Цель
Отделить обновление мира (game loop) от UI/ввода и безопасно синхронизировать состояние.

## Рекомендуемая схема
- Поток A: GameLoop
  - фиксированный dt=1/60
  - обновляет GameModel через сервис `GameWorldUpdateService`
  - публикует события о changed-state
- Поток B: UI/Input
  - читает ввод (консоль) или принимает события UI (Avalonia UI thread)
  - отправляет команды в контроллер (например, MoveLeft/MoveRight/TogglePause)

## Синхронизация
Выберите один из вариантов (и придерживайтесь его везде):
1) `lock` вокруг общего состояния модели + snapshot для View
2) Immutable state + atomic swap (Interlocked.Exchange)
3) Channel/queue команд: UI кладёт команды, GameLoop читает их в начале тика

## Запрет таймеров
Не использовать Timer/DispatcherTimer.
Для поддержания частоты тиков допускается:
- измерение времени `Stopwatch`
- ожидание остатка через `Thread.Sleep` (или эквивалент), не создавая Timer-объектов.

## Важно для Avalonia
UI можно обновлять так:
- GameLoop публикует событие -> UI подписчик делает `Dispatcher.UIThread.Post(() => InvalidateVisual())`
- отрисовка берёт snapshot состояния (чтобы не лочить модель на длительное время).
